import numpy
from numba import njit
from .utils import (
    acq_mat, ps0, z2inv, pauli_combine, pauli_transform, binary_repr,
    random_pauli, random_clifford, map_to_state, state_to_map, clifford_rotate,
    stabilizer_measure, stabilizer_postselect, stabilizer_project, stabilizer_expect, 
    stabilizer_entropy, mask)
from .paulialg import Pauli, PauliList, PauliPolynomial, pauli, paulis

class CliffordMap(PauliList):
    '''Represents a Clifford map. This is a subclass of PauliList.
    
    Idea: a most general Clifford transformation is specified by the operator
    mapping (how each single Pauli maps to under the trnasformation):
    X0 -> U X0 U^dagger = Pauli[g0,p0]
    Z0 -> U Z0 U^dagger = Pauli[g1,p1]
    X1 -> U X1 U^dagger = Pauli[g2,p2]
    Z1 -> U Z1 U^dagger = Pauli[g3,p3]
    ....
    The operators [g0,g1,g2,g3,...] forms a PauliList.

    Parameters:
    gs: int (2*N, 2*N) - strings of Pauli operators to be mapped to.
    ps: int (2*N) - phase indicators of Pauli operators to be mapped to.'''
    def __init__(self, *args, **kwargs):
        # call superclass PauliList to handle arguments
        super(CliffordMap, self).__init__(*args, **kwargs)

    def __repr__(self):
        xz = {0:'X',1:'Z'}
        l = str(int(numpy.ceil(numpy.log10(self.N))))
        dis = '{}{:<'+l+'d}->{}'
        if self.N <= 10:
            lns = [dis.format(xz[i%2], i//2, pauli) for i, pauli in enumerate(self)]
            return 'CliffordMap(\n{})'.format('\n'.join(lns)).replace('\n','\n  ')
        else:
            lns1 = [dis.format(xz[i%2], i//2, pauli) for i, pauli in zip(range(10), self[:10])]
            lns2 = [dis.format(xz[i%2], i//2, pauli) for i, pauli in zip(range(self.L-10, self.L), self[-10:])]
            return 'CliffordMap(\n{}\n   ...\n{})'.format('\n'.join(lns1),'\n'.join(lns2)).replace('\n','\n  ')
    
    def expand(self, N):
        if N is not None and N > self.N:
            return identity_map(N).embed(self, mask(range(self.N), N))
        else:
            return self
    
    def copy(self):
        return CliffordMap(self.gs.copy(), self.ps.copy())

    def to_state(self, r=0):
        '''Interprete the Clifford map as a stabilizer state, such that the
            state is generated by the map from the zero state.'''
        gs, ps = map_to_state(self.gs, self.ps)
        return StabilizerState(gs, ps, r=r)

    def embed(self, small_map, mask):
        '''Embed a smaller map acting on a subsystem specified by qubit indices.'''
        mask2 = numpy.repeat(mask, 2)
        self.gs[numpy.ix_(mask2, mask2)] = small_map.gs
        self.ps[mask2] = small_map.ps
        return self

    def compose(self, other):
        '''Returns the composition of this map with the other map (this map
        will transform first in the forward transformation). This is equivalent
        to tranforming the Pauli operators in this map by the next map.'''
        gs, ps = pauli_transform(self.gs, self.ps, other.gs, other.ps)
        return CliffordMap(gs, ps)

    def inverse(self):
        '''Returns the inverse of this Clifford map, (such that it composes with
        its inverse results in identity map).'''
        gs_inv = z2inv(self.gs)
        _, ps_mis = pauli_combine(gs_inv, self.gs, self.ps)
        ps_inv = (- ps_mis - ps0(gs_inv))%4
        return CliffordMap(gs_inv, ps_inv)

class StabilizerState(PauliList):
    '''Represents a stabilizer state. This is a subclass of PauliList.
        rho = 1/2^r prod_{a=1}^{N-r} (1+ Pauli[g_a,p_a])/2

    The stabilizer state is specified by a stablizer tableau, as a binary matrix
    of the shape (2*N, 2*N).
        rows [0,r) - standby stabilizers
        rows [r,N) - active stabilizers (g_a)
        rows [N,N+r) - standby destabilizers
        rows [N+r,2*N) - active destabilizers
    The stabilizers and destablizers in the tableau forms a list of Pauli 
    operators, which can be represented as a subclass of PauliList.

    Parameters:
    gs: int (2*N, 2*N) - strings of Pauli operators in the stabilizer tableau.
    ps: int (2*N) - phase indicators (should only be 0 or 2).
    r:  int  - number of logical qubits (log2 rank of density matrix)
        (r can only be provided as a keyword argument)'''
    def __init__(self, *args, **kwargs):
        # extract r and remove it from kwargs, if present.
        # otherwise, set r = 0 as pure state by default.
        self.r = kwargs.pop('r', 0) 
        # call superclass PauliList to handle remaining arguments
        super().__init__(*args, **kwargs)
        
    def __repr__(self):
        ''' will only show active stabilizers, 
            to see the full stabilizer tableau, convert to PauliList by [:] '''
        subrepr = repr(self.stabilizers)
        if subrepr == '':
            return 'StabilizerState()'
        else:
            return 'StabilizerState(\n{})'.format(subrepr).replace('\n','\n  ')

    @property
    def stabilizers(self):
        return self[self.r:self.N]

    def expand(self, N):
        if N is not None and N > self.N:
            return stabilizer_state(self.stabilizers.expand(N))
        else:
            return self
    
    def copy(self):
        return StabilizerState(self.gs.copy(), self.ps.copy(), r=self.r)

    def to_map(self):
        '''Interprete the stabilizer state as its encoding Clifford map.'''
        gs, ps = state_to_map(self.gs, self.ps)
        return CliffordMap(gs, ps)

    def measure(self, obs):
        '''Perform Pauli observable measurement on the stabilizer state.
           - sample measurement outcomes from:
                p(out_k = 0|rho) = (1 + Tr(rho obs_k))/2
                p(out_k = 1|rho) = (1 - Tr(rho obs_k))/2
           - collapse the state to the posterior state conditioned on 
             the measurement outcomes. (in-place update)
        
        Parameters:
        obs: PauliList or StabilizerState (only active stabilizers measured)

        Returns:
        out: int (L) - array of measurement outcomes of corresponding observables.
        log2prob: real - log2 probability of sampling this set of outcomes.'''
        if isinstance(obs, StabilizerState):
            obs = obs.stabilizers
        self.gs, self.ps, self.r, out, log2prob = stabilizer_measure(
            self.gs, self.ps, obs.gs, obs.ps, self.r)
        return out, log2prob

    def postselect(self, obs, out=None):
        '''Postselect the stabilizer state on a set of Pauli observables, 
           such that on the postselected state:
           - default behavior:     <obs_k> = +1,
           - with target outcomes: <obs_k> = (-1)^{out_k},
           The postselected state is in-place updated.
        
        Parameters:
        obs: PauliList or StabilizerState (only active stabilizers postselected)
        out: int (L) - array of target measurement outcomes of corresponding observables.
             default is None, meaning <obs_k> = +1.

        Returns:
        log2prob: real - log2 probability for postselection to succeed.'''
        if isinstance(obs, StabilizerState):
            obs = obs.stabilizers
        if out is None:
            obs_ps = obs.ps
        else: # encode target outcomes to operator phases
            obs_ps = (obs.ps + 2*out)%4 # modify operator phases
        self.gs, self.ps, self.r, log2prob = stabilizer_postselect(
            self.gs, self.ps, obs.gs, obs_ps, self.r)
        return log2prob

    def expect(self, obs, z=1.):
        '''Evaluate expectation values of observables on the statilizer state.
        
        Parameters:
        obs: observable, can be Pauli, PauliList, PauliPolynomial, StabilizerState
        z: fugacity of operator weight, it is not used when obs is StabilizerState
           default is 1. Setting z = 3 for Pauli shadow tomography directly.

        Returns:
        out: output (depending on the type of obs)
            * Pauli: promote to PauliPolynomial
            * PauliPolynomial O: Tr(rho O z^|O|)
            * StabilizerState sigma: Tr(rho sigma) = p(sigma|rho)
            * PauliList [O_i]: [Tr(rho O_i z^|O_i|)]
        '''
        if isinstance(obs, Pauli):
            return self.expect(obs.as_polynomial()) # cast Pauli to PauliPolynomial
        elif isinstance(obs, PauliPolynomial):
            # cast PauliPolynomial to PauliList for expectation value calculation
            xs = self.expect(PauliList(obs.gs, obs.ps))
            if z != 1.: # if fugacity not 1, multiply by fugacity to the power of operweight
                zs = z ** obs.weight()
                xs = xs * zs
            return numpy.sum(obs.cs * xs) # combine expectation values by coefficients
        elif isinstance(obs, StabilizerState):
            rho = self.copy() # make a copy to avoid in-place update in postselection
            log2prob = rho.postselect(obs) # use post-selection to calculate Tr(rho obs)
            return 2. ** log2prob # convert log2 probability to probability
        # WARNING: PauliList instance must be placed after StabilizerState instance
        #          otherwise StabilizerState will be shadowed by PauliList as subclass
        elif isinstance(obs, PauliList):
            xs = stabilizer_expect(self.gs, self.ps, obs.gs, obs.ps, self.r)
            if z != 1.: # if fugacity not 1, multiply by fugacity to the power of operator weight
                zs = z ** obs.weight()
                xs = xs * zs
            return xs
        else:
            raise ValueError("Unsupported observable type: {}".format(type(obs)))

    def to_numpy(self):
        """Convert stabilizer state to numpy density matrix representation.
        Returns a (2^N, 2^N) array representing rho = 1/2^r prod_{a=1}^{N-r} (1+ Pauli[g_a,p_a])/2
        """
        # Define all Pauli matrices as a single 4x2x2 array
        sigma = numpy.array([
            [[1, 0], [0, 1]],      # I (00)
            [[0, 1], [1, 0]],      # X (10)
            [[0, -1j], [1j, 0]],   # Y (11)
            [[1, 0], [0, -1]]      # Z (01)
        ], dtype=complex)
        # Handle empty state case
        if self.N == 0:
            return numpy.ones((1, 1), dtype=complex)
        # Only process active stabilizers
        active_gs = self.gs[self.r:self.N]  # Shape: (N-r, 2N)
        active_ps = self.ps[self.r:self.N]  # Shape: (N-r,)
        # For each active stabilizer, get its Pauli matrices
        matrices = []
        for i in range(self.N):
            # Map binary representation (x,z) to Pauli matrix index for all active stabilizers
            # This maps: (0,0)->0 (I), (1,0)->1 (X), (1,1)->2 (Y), (0,1)->3 (Z)
            idx = (active_gs[:,2*i] + 3*active_gs[:,2*i+1] - 
                  2*active_gs[:,2*i]*active_gs[:,2*i+1])  # Shape: (N-r,)
            # Select corresponding Pauli matrices for all active stabilizers
            matrices.append(sigma[idx])  # Shape: (N-r, 2, 2)
        # Compute tensor product for each active stabilizer simultaneously
        result = matrices[0]  # Shape: (N-r, 2, 2)
        for mat in matrices[1:]:
            # Reshape for broadcasting:
            # result: (N-r,m,m) -> (N-r,m,1,m,1)
            # mat: (N-r,2,2) -> (N-r,1,2,1,2)
            m = result.shape[1]
            result = result.reshape(self.N-self.r, m, 1, m, 1)
            mat = mat.reshape(self.N-self.r, 1, 2, 1, 2)
            # Broadcast multiply and reshape back
            result = (result * mat).reshape(self.N-self.r, m*2, m*2)
        # Apply phases to get Pauli operators
        pauli_ops = (1j)**(active_ps[:,None,None]) * result  # Shape: (N-r, 2^N, 2^N)
        # Construct density matrix using the formula
        rho = numpy.eye(2**self.N, dtype=complex)  # Start with identity
        for op in pauli_ops:
            rho = rho @ (numpy.eye(2**self.N) + op) / 2
        # Apply normalization factor
        return rho / (2**self.r)

    def entropy(self, subsys):
        '''Entanglement entropy of the stabilizer state in a given region.'''
        if isinstance(subsys, (tuple, list)):
            subsys = numpy.array(subsys)
        if len(subsys) == 0:
            return 0
        else:
            if not isinstance(subsys[0], numpy.bool_):
                subsys = mask(subsys, self.N)
        return stabilizer_entropy(self.stabilizers.gs, subsys)

    def tokenize(self):
        return self.stabilizers.tokenize()
    
    def sample(self, L):
        '''Sample stabilizers from the stabilizer group.'''
        C = numpy.random.randint(2, size=(L,self.N-self.r))
        gs, ps = pauli_combine(C, self.gs[self.r:self.N], self.ps[self.r:self.N])
        return PauliList(gs, ps)


    def get_prob(self, out):
        '''Evaluate the probability of getting a bit string readout.
           Assume computational basis measurement.'''
        if self.N != out.shape[0]:
            raise ValueError("readout size {} is incompatible with system size {}!".format(out.shape[0], self.N))
        return self.expect(bit_state(self.N, out))


    # !!! this function has exponential complexity.
    @property
    def density_matrix(self):
        '''Expand stabilizer state as density matrix in PauliPolynomial representation.
        '''
        C = binary_repr(numpy.arange(2**(self.N-self.r)))
        gs, ps = pauli_combine(C, self.gs[self.r:self.N], self.ps[self.r:self.N])
        return PauliPolynomial(gs, ps) / 2**self.N

    def __neg__(self):
        return -self.density_matrix

    def __rmul__(self, other):
        return other * self.density_matrix

    def __truediv__(self, other):
        return self.density_matrix/other

    def __add__(self, other):
        return self.density_matrix + other

    def __radd__(self, other):
        return self.density_matrix + other

    def __sub__(self, other):
        return self.density_matrix - other

    def __matmul__(self, other):
        return self.density_matrix @ other

# ---- map constructors ----
def identity_map(N):
    '''construct identity Clifford map of N qubits.'''
    gs = numpy.eye(2*N, dtype=numpy.int_)
    return CliffordMap(gs)

def random_pauli_map(N):
    '''construct random Pauli map of N qubits.'''
    gs = random_pauli(N) # shape (2*N, 2*N), mapping matrix
    ps = 2 * numpy.random.randint(0,2,2*N) # shape (2*N), phase indicator
    return CliffordMap(gs, ps)

def random_clifford_map(N):
    '''construct random Clifford map of N qubits.
        drawn from N-qubit Clifford group uniformly.'''
    gs = random_clifford(N) # shape (2*N, 2*N), mapping matrix
    ps = 2 * numpy.random.randint(0,2,2*N) # shape (2*N), phase indicator
    return CliffordMap(gs, ps)

def clifford_rotation_map(gen):
    '''construct Clifford map from generator.'''
    gen = pauli(gen)
    gs = numpy.eye(2*gen.N, dtype=numpy.int_) # initialize
    ps = numpy.zeros(2*gen.N, dtype=numpy.int_) # initialize
    gs, ps = clifford_rotate(gen.g, gen.p, gs, ps)
    return CliffordMap(gs, ps)

# ---- state constructors ----
def stabilizer_state(*stabilizers):
    '''Construct a stabilizer state from a list of stabilizers

    Parameters:
    stabilizers: PauliList or descriptions of stabilizers.'''
    stabilizers = paulis(*stabilizers) # parsing input to PauliList
    # validity check:
    if not (acq_mat(stabilizers.gs) == 0).all():
        raise ValueError('stabilizers must all commute with each other.')
    state = maximally_mixed_state(stabilizers.N)
    state.gs, state.r = stabilizer_project(state.gs, numpy.flipud(stabilizers.gs), state.r)
    state.ps[state.r:state.N] = stabilizers.ps
    return state

def maximally_mixed_state(N):
    return identity_map(N).to_state(r=N)

def zero_state(N):
    return identity_map(N).to_state()

def one_state(N):
    gs = zero_state(N).gs
    ps = (2*numpy.ones(2*N)).astype(int)
    return StabilizerState(gs = gs,ps = ps)

def bit_state(N, bits):
    # bits should be a binary array of length N. 
    # if bits is represented as integer or string, convert to array
    if isinstance(bits, int):
        bits = numpy.array(list(numpy.binary_repr(bits, width=N))).astype(int)
    elif isinstance(bits, str):
        if len(bits) != N:
            raise ValueError("bitstring must be of length N")
        bits = numpy.array(list(bits)).astype(int)
    gs = zero_state(N).gs
    ps = 2*bits
    return StabilizerState(gs = gs, ps = ps)

def ghz_state(N):
    objs = [pauli({i:3,i+1:3},N) for i in range(N-1)]
    objs.append(pauli([1]*N))
    return stabilizer_state(paulis(objs))

def random_pauli_state(N, r=0):
    return random_pauli_map(N).to_state(r)

def random_clifford_state(N, r=0):
    return random_clifford_map(N).to_state(r)

@njit
def random_bit_state_gs_ps(N):
    gs = numpy.zeros((2*N,2*N))
    for i in range(N):
        gs[i,2*i+1]=1
        gs[N+i,2*i]=1
    ps = numpy.random.choice(numpy.array([0,2]),size = 2*N)
    return gs, ps

def random_bit_state(N):
    gs, ps = random_bit_state_gs_ps(N)
    return StabilizerState(gs = gs.astype(int), ps = ps)